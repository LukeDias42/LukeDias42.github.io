# C# and .NET study
- [C# and .NET study](#c-and-net-study)
- [Basic (For beginners)](#basic-for-beginners)
  - [C# History](#c-history)
  - [Primitive Types and Expressions](#primitive-types-and-expressions)
  - [Non-Primitive and Expressions](#non-primitive-and-expressions)
  - [Control Flow](#control-flow)
  - [Arrays and Lists](#arrays-and-lists)
  - [Working with Dates](#working-with-dates)
  - [Working with Text](#working-with-text)
  - [Working with Files](#working-with-files)
- [Intermediary (Classes, interfaces and OOP)](#intermediary-classes-interfaces-and-oop)
  - [Object Oriented Programming](#object-oriented-programming)
  - [Classes](#classes)
    - [Constructor](#constructor)
    - [Objects](#objects)
    - [Fields](#fields)
    - [Access Modifiers](#access-modifiers)
    - [Class Coupling](#class-coupling)
    - [Abstract Modifier](#abstract-modifier)
    - [Sealed Modifier](#sealed-modifier)
    - [Class Inheritance](#class-inheritance)
      - [Upcasting and Downcasting](#upcasting-and-downcasting)
    - [Composition](#composition)
    - [Composition Over Inheritance](#composition-over-inheritance)
  - [Interface](#interface)
  - [Methods](#methods)
  - [Types](#types)
    - [Value Types](#value-types)
    - [Reference Types](#reference-types)
    - [Boxing](#boxing)
    - [Unboxing](#unboxing)
- [Advanced](#advanced)
  - [Generics](#generics)
    - [Example of generic method vs. generic class](#example-of-generic-method-vs-generic-class)
    - [Example of not using generic vs. using generic](#example-of-not-using-generic-vs-using-generic)
  - [Delegates](#delegates)
    - [Interfaces or Delegates?](#interfaces-or-delegates)
    - [Example of generic delegate](#example-of-generic-delegate)
    - [Example of not using vs. using delegates vs. using Action](#example-of-not-using-vs-using-delegates-vs-using-action)
  - [Lambda Expressions](#lambda-expressions)
  - [Events](#events)
  - [Extension Methods](#extension-methods)
  - [LINQ](#linq)
  - [Nullable Types](#nullable-types)
  - [Dynamic](#dynamic)
  - [Exception Handling](#exception-handling)
  - [Async / Await](#async--await)
- [Big O](#big-o)
- [Data Structures](#data-structures)
  - [Arrays](#arrays)
  - [Hash Tables](#hash-tables)
  - [Linked Lists](#linked-lists)
  - [Stacks + Queues](#stacks--queues)
  - [Trees](#trees)
  - [Graph](#graph)
- [Algorithms](#algorithms)
  - [Sorting](#sorting)
  - [Searching](#searching)
  - [Dynamic Programming](#dynamic-programming)
- [Design Patterns](#design-patterns)
  - [SOLID](#solid)
    - [**Single Responsability Principle**](#single-responsability-principle)
    - [**Open-Closed Principle**](#open-closed-principle)
    - [**Liskov Substitution Principle**](#liskov-substitution-principle)
    - [**Interface Segregation Principle**](#interface-segregation-principle)
    - [**Dependency Injection Principle**](#dependency-injection-principle)
    - [Summary](#summary)
  - [Gamma Categorization](#gamma-categorization)
- [Creational Patterns](#creational-patterns)
  - [Builder](#builder)
    - [Fluent Builder](#fluent-builder)
      - [Fluent builder Inheritance with Recursive Generics](#fluent-builder-inheritance-with-recursive-generics)
    - [Functional Builder](#functional-builder)
      - [Generic Functional Builder](#generic-functional-builder)
    - [Faceted Builder](#faceted-builder)
  - [Factories](#factories)
  - [Singleton](#singleton)
- [Structural Patterns](#structural-patterns)
  - [Adapter](#adapter)
  - [Bridge](#bridge)
  - [Composite](#composite)
  - [Decorator](#decorator)
  - [Façade](#façade)
  - [Flyweight](#flyweight)
  - [Proxy](#proxy)
- [Behavioral Patterns](#behavioral-patterns)
  - [Chain of Responsability](#chain-of-responsability)
  - [Command](#command)
  - [Interpreter](#interpreter)
  - [Iterator](#iterator)
  - [Mediator](#mediator)
  - [Memento](#memento)
  - [Null Object](#null-object)
  - [Observer(https://refactoring.guru/design-patterns/observer)](#observerhttpsrefactoringgurudesign-patternsobserver)
  - [State(https://refactoring.guru/design-patterns/state)](#statehttpsrefactoringgurudesign-patternsstate)
  - [Strategy](#strategy)
  - [Template Method](#template-method)
  - [Visitor](#visitor)
- [Refactoring](#refactoring)
  - [Code Smells](#code-smells)
    - [Bloaters](#bloaters)
    - [Long Methods](#long-methods)
      - [Recipe #1](#recipe-1)
      - [Recipe #2](#recipe-2)
      - [Recipe #3](#recipe-3)
      - [Recipe 4](#recipe-4)
      - [Payoff](#payoff)
    - [Large Class](#large-class)
      - [Recipe 1](#recipe-1-1)
      - [Recipe #2](#recipe-2-1)
      - [Recipe #3](#recipe-3-1)
      - [Recipe 4](#recipe-4-1)
      - [Payoff](#payoff-1)
    - [Primitive Obsession](#primitive-obsession)
- [Multithreading](#multithreading)
  - [Asynchrony](#asynchrony)
  - [Thread](#thread)
    - [ThreadPool and Scheduling](#threadpool-and-scheduling)
  - [Multithreading](#multithreading-1)
  - [Parallel Computing](#parallel-computing)
  - [Concurrency](#concurrency)
- [ASP.NET Core](#aspnet-core)
  - [Introduction to .NET Core (Which now is only called .NET)](#introduction-to-net-core-which-now-is-only-called-net)
- [Made by](#made-by)

# Basic (For beginners)
## C# History
## Primitive Types and Expressions
## Non-Primitive and Expressions
## Control Flow
## Arrays and Lists
## Working with Dates
## Working with Text
## Working with Files

# Intermediary (Classes, interfaces and OOP)

## Object Oriented Programming
- Encapsulation / Information Hiding
- Inheritance
- Polymorphism

## [Classes](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/classes)
A class is the building block of an application.
Each application has multiple classes, each describing the behavior of an action this application dows.

### Constructor
A way of creating an instance of the class with some data already filled in.
- Constructor Overloading
    Whem there are more than two ways of creating an instance of the object. For example when you don't know some information, but knows other stuff.s

- Constructor Inheritance
    You can use the "base" keyword in order to call a mother class constructor with the correct parameters.
    Example:
    ```` C#
    class Vehicle{
        private string _registrationNumber;
        public Vehicle(string registrationNumber){
            _registrationNumber = registrationNumber;
        }
    }
    class Car : Vehicle{
        public Car(string registrationNumber) : base(registrationNumber){
            // Initializes fields specific to the car class
        }
    }
    ````
### Objects
An object is an instance of a class.
It will have all methods and elements the class has, however each instance will have different elements;

- Initializer
    It will initialize the object with the data you want, without creating too many constructors

### Fields
Fields are the global variables of a class. They can be other isntance of classes (including itself), they can be primitive values, Data Structures. You can initialize a field by passing it through a constructor, or by simply initializing it when declaring it. A field can be:
- Readonly
- Const
- static
- unsafe
- virtual
- volatile

### [Access Modifiers](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/access-modifiers)
An access modifier is a way to control access to a class or it's members.
Encapsulation (in practice)
- Define fields as private 
- Provide getter/setter moethods as public
  - Example:
    ``` C#
    public class Person{
        private string _name;

        public void SetName(string name){
            if (!string.IsNullOrEmpty(name))
                _name = name;
        }

        public string GetName(){
            return _name;
        }
    }
    ```
    #### **Or if you are using properties:**
    ``` C#
        private string _name;
        public string Name{
            get => _name;
            set{
                if (!string.IsNullOrEmpty(name))
                _name = name;
            }
        }
    ```
    #### **Or if you won't use the if statement:**
    ``` C#
        public string Name { get; set;}
    ```
    #### **Another example:***
    ``` C#
        public DateTime Birthday { get; set;}
        public int Age{
            get{
                var timeSpan = DateTime.Today - Birthdate;
                var years = timeSpan.Days/365

                return years;
            }
        }
    ```
- All the access modifiers:
  - Public
    Can accessed from everywhere.
  - Private
    Only accessible from the class it is created.
  - Protected
    Only accessible from the class and its derived classes. Breaks encapsulation.
  - Inernal
    Accessible only from the same assembly. Usually the class is declared as internal.
  - Protected Internal
    Accessible only from the same assembly or any derived classes.

### Class Coupling
A class should be loosely coupled, able to change without interfering with other classes that inherits and uses it.

### [Abstract Modifier](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/abstract)
When you declare an abstract class, it means it cannot be instantiated, and also that you can declare abstract methods inside of it. 
- Abstract Methods:
  - An abstract cannot have any implementation, which gives you the ability to override it in every child class.
  - You can create normal methods inside abstract classes

### [Sealed Modifier](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/sealed)
Sealed classes are slightly faster because of some runtime optimizations.
A sealed class cannot be inherited. A virtual method that has been overidden can have the sealed modifier, meaning that any class that inherits from the one with the method cannot overide it.

### [Class Inheritance](https://docs.microsoft.com/dotnet/csharp/tutorials/inheritance)
A class can inherit all the methods and fields of another class. Which allows the class to add methods and fields that are only important to itself, without interfering with the mother class.
Example:
```` C#
namespace LivingBeings{
    public class Animal{
        public string Name;
        public int Age;

        public void Sleep(){
            Console.WriteLine("ZZZzzzzZZZZZZZZZzzzZZZ");
        }
    }

    public class Dog{
        public void Bark(){
            Console.WriteLine("Au au au au auuuuuuu");
        }
    }

    public class Program{
        Dog dog = new Dog();
        Dog.Name = "Doguinho";
        Dog.Age = 4;

        Dog.Sleep();
        Dog.Bark();
    }
}
````
#### Upcasting and Downcasting
- Upcasting
  - You can implicitly upcast a child class into a mother class. In the below example I am referencing the circle object with a Shape-type object. 
  ```` C#
  Circle circle = new Circle();
  Shape shape = circle;
  ````

- Downcasting
  -   You can explicitly downcast a mother class into a child class.
  ```` C#
  Shape  shape = new Shape();
  Circle circle = (Circle) shape;
  ````

- You should use the **as** keyword in order to catch conversion exceptions:
````C#
Shape shape = new Shape();
Circle circle = shape as Circle;
if (circle != null){
    // stuff
}
````

- You can use the **is** keyword in order to check the type of the object
```` C#
Shape shape = new Shape();
if (shape is Shape){
    // stuff
}
```` 

- Why would you want a more limited view of a object?
  - You can send a mother class of a more complex child object somewhere that does not need to have acces to that object, you do that using upcasting.
  - You can also access this object again and do necessary operations on it using downcasting.

 
### Composition
It is more flexible than inheritance. You have an object of that class inside another class, allowing you to use its methods without inheriting from it.
Example:
````C#
public class Installer{
    private Logger _logger;
    
    public Installer(Logger logger){
        _logger = logger;
    }
}
````

### Composition Over Inheritance
Composition leaves the code less tightly couples. Inheritance can be easily overused, creating a lot of dependency.

Problems with inheritance:
- Easily abused by amateurs designers / developers;
- Large Hierarchies
- Fragility
- Tightly Coupled

Composition:
- Any inheritance relationship can be translated to Composition
- Great Flexibility
- Eventually loose coupling

- Pros and Cons
  - Inheritance:
    - Pros: Code re-use, easier to understand
    - Cons: Tightly coupled, fragile, can be used
  - Composition:
    - Pros: Code re-use, great flexibility, loose coupling
    - Cons: A little harder to understand

## [Interface](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/interface)
An interface is a language construct that is similar to a class (in terms of syntax), but is fundamentally different. An interface can only have declarations of methods, but they can't really implement anything on them.
You should use it to build loosely-coupled applications.
```` C#
public interface Vehicle{
    float CalculateTimeToArrive();
    float CalculateAvarageTimeToConsumeFuel();
}

public class Car{
    public float CalculateTimeToArrive(){
        // Some implementation
    }

    public float CalculateAvarageTimeToConsumeFuel(){
        // Some implementation
    }
}

public class Moto{
    public float CalculateTimeToArrive(){
        // Another implementation
    }

    public float CalculateAvarageTimeToConsumeFuel(){
        // Another implementation
    }
}
````

## [Methods](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/methods)
They are operations you make inside a class. Your logic will be inside the method.
- Overload
    The overload allows you to have many methods with the same name that does different things.
- Params Modifier
    The params modifier allows you to not necessarily need to instantialize an array before passing it as a parameter
    Example:
    ```C#
    public class Calculator
    {
        public int Add(params int[] numbers) {}
    }

    var result = calculator.Add(1, 2, 3, 4, 5);
    ```

- Override
  - Modifying the implementation of an inherited method.
  ```` C#
  public class Shape{
      public virtual void Draw(){
          // Default implementation
      }
  }

  public class Circle : Shape{
      public override void Draw(){
          // New Implementation
      }
  }
  ````

- Ref Modifier
    The ref modifier allows you to pass a value type as a parameter in a method, and let the method change it, instead of copying it and doing something else.
    However, it is considered to be a code smell, and should be avoided.
    Example:
    ``` C#
    public class Adds{
        public void AddTwo(ref int a){
            a += 2
        }   
    }
    var a = 1;
    adds.AddTwo(ref a);
    ```

- Out Modifier
    The out modifier make the parameter of the method to be returned. No matter what value you pass in the param, at the end of the method, that valued will be returned to the assigned variable.
    Like the ref modifier, the out modifier is a code smell and should be avoided.
    Example:
    ``` C#
    public class MyClass
    {
        public void MyMethod(out int result){
            result = 1;
        }
    }

    int a;
    myClass.MyMethod(out a);
    ```

## Types

### [Value Types](https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/value-types)
- Are stored on the Stack.
- Examples:
    - All primitive types: byte, int, float, char, bool
    - The Struct type

### [Reference Types](https://docs.microsoft.com/dotnet/csharp/language-reference/keywords/reference-types)
- Are stored on the heap
- Examples
  - Any classes (Object, Array, String, DbMigrator, etc);

### [Boxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing)
- The process of cconverting a value type instance to an object reference. It means you can save something that would usually be saved on the **stack** in the **heap**.
```` C#
int number = 10;
object obj = number;

//or
object obj = 10;
````
### [Unboxing](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/boxing-and-unboxing)
- The process of converting an object reference into a value type instance. It means you can save something that would usually be saved on the **heap** in the **stack**.
```` C#
object obj = 10;
int number = (int)obj;
````

# Advanced

## [Generics](https://docs.microsoft.com/dotnet/csharp/programming-guide/generics/)
Generic classes are classes that have a T type which is defined upon instantiation.
Custom Generic classes are very rare, you will more frequently use the Generic Data Structures that already comes with .NET. 
- You can also have a generic method inside a non-generic class
- You can set constraints to the generic type, in order to stabilish what the class will receive and avoid erroes
  - Examples:
  -  constraint to an Interface (where T : IComparable)
  -  constraint to an specific class (where T : Product)
  -  constrains to a value type (where T : struct)
  -  constrains to reference type (where T : class)
  -  You can also say that T has a default constructor (where T : new())
- T can actually have any name, but it is standard that the name starts with a T

### Example of generic method vs. generic class
```` C#
public class Uttilities{
    public T Max<T>(T a, T b) where T : IComparable{
        return a.Compare(b) > 0 ? a : b;
    }
}

// Or 

public class Utilities<T> where T : IComparable{
    public T Max(T a, T b ){
        return a.Compare(b) > 0 ? a : b;
    }
}
````

### Example of not using generic vs. using generic
```` C#
// The problem with this class is of performance
// Every time you want to add an a value type into the list you will have to unbox it for it to become a reference type
public class ObjectList
{
    public void Add(object obj){
        // Add the object
    }

    public Book this[int index]{
        get {// Returns the object}
    }
}

// This is better because:
// 1- The object will have only one type, which is easier to protect
// 2- No performance penalty, because there won't be any boxing or unboxing
public class GenericList<T>
{
    public void Add(T value)
    {
        // Add T to the list
    }

    public T this[int index]
    {
        get { // returns T }  
    }
}
````

## [Delegates](https://docs.microsoft.com/dotnet/csharp/programming-guide/delegates/using-delegates)
- A delegate is an object that knows how to call an object or a group of methods
- It is a reference to a function

- Why do we need delegates?
  - For designing extensible and flexible applications (like frameworks)

- In C# there are also generic delegates called Action and Func
  - Func points to a method that returns a value
  - Action points to a methods that returns void

### Interfaces or Delegates?
Use a delegate when
- An eventing design pattern is used.
- The caller doesn't need to acces other properties or methods on the object implementing the method.


### Example of generic delegate
```` C#
// The Action delegate can have from 1 up to 16 parameters, and can point to any method that takes this amount of paramters.
System.Action<>

// The Func delegate can also have from 1 up to 16 parameters, however, one of those parameters must be the return of that function.
System.Func<>
````

### Example of not using vs. using delegates vs. using Action
```` C#
// This code is not extensible
// What if another developer wants to use another filter?
// It will have to add the filter to the code and them recompile and deplou
public class PhotoProcessor{
    public void Process(string path){
        var photo = Photo.Load(path);
        var filters = new PhotoFilters();
        filters.ApplyBrightness(photo);
        filters.ApplyContrast(photo);
        filters.Resize(photo);
        photo.Save();
    }
}

// Or with Delegate

// It does not know which filter will be applied to the code
// Each developer can send whichever filter it wants to be applied to the photo
// It allows you to create very flexible applications
public class PhotoProcessor{
    public delegate void PhotoFilterHandler(Photo photo);

    public void Process(string path, PhotoFilterHandler filterHandler){
        var photo = Photo.Load(path);
        
        filterHandler(photo);

        photo.Save();
    }
}

public class Prgram{
    public static void Main(){
        var processor = new PhotoProcessor();
        var filters = new PhotoFilters();
        PhotoProcessor.PhotoFilterHandler filteHandler = filters.ApplyBrightness;
        filterHandler += filters.ApplyContrast;
        filterHandler += filters.Resize;
        filterHanlder += filters.RemoveRedEyeFilter;

        processor.Process("photo.JPG", filterHandler);
    }
}

// Or with Action
public class PhotoProcessor{
    public void Process(string path, Action<Photo> filterHandler){
        var photo = Photo.Load(path);

        filterHandler(photo);

        photo.Save();
    }

    public class Prgram{
        public static void Main(){
            var processor = new PhotoProcessor();
            var filters = new PhotoFilters();
            Action<Photo> filteHandler = filters.ApplyBrightness;
            filterHandler += filters.ApplyContrast;
            filterHandler += filters.Resize;
            filterHanlder += filters.RemoveRedEyeFilter;

            processor.Process("photo.JPG", filterHandler);
    }
}
````



## [Lambda Expressions](https://docs.microsoft.com/dotnet/csharp/language-reference/operators/lambda-operator)
- A lambda expression is an anonymous method
    - No access modifier
    - No name
    - No return statement

- Why use lambda expression?
  - For convenience -> You can write less code to achieve the same thing, making the code more readable

- A lambda expression can have 
  - No arguments at all 
  ```` C#
  () => // implementation
  ````
  - One argument
  ```` C#
  x => // implementation
  ````
  - Multiple arguments
  ```` C#
  (x, y, w, z) => //implementation
  ````

- A predicate is a delegate which points to a method that gets an object from a list and returns a boolean value specifying if a given condition was satisfied

```` C#
class Program{
    static void Main(){
        // args => expression
        // number => number*number

        // type of paramter, type of return
        Func<int, int> square = number => number * number;

        const int factor = 5;

        Func<int, int> multiplier = n => n*factor;

        
        Console.WriteLine(multiplier(10));
        Console.WriteLine(Square(5));
    }
}
````

```` C#
public class BookRepository{
    public List<Book> GetBook(){
        return new List<Book>{
            new Book() {Title = "Title 1", Price = 5},
            new Book() {Title = "Title 2", Price = 7},
            new Book() {Title = "Title 3", Price = 10}
        };
    }
}

public class Program{
    public static void Main(){
        var books = new BookRepository().GetBooks();

        var cheapBooks = books.FindAll(IsCheaperThan10Dollars);

        foreach (var book in cheapBooks){
            Console.WriteLine(book.Title);
        }
    }

    static bool IsCheaperThan10Dollars(Book book){
        return book.Price < 10;
    }
}

// Or using Lambda Expressions

public class Program{
    public static void Main(){
        var books = new BookRepository().GetBooks();

        var cheapBooks = books.FindAll(b => b.Price < 10);

        foreach (var book in cheapBooks){
            Console.WriteLine(book.Title);
        }
    }
}
````



## [Events](https://docs.microsoft.com/pt-br/dotnet/csharp/language-reference/keywords/event)
- A mechanism for communication between objects
- Used in building Loosely Coupled Applications
- Helps extending applications

- In events you need a publisher (or event sender) and a subscriber (event receiver), and the advantage is that the publisher does not need to know anything about the subscriber
  - The publisher can evoke the method on the subscriber
    - For the publisher to know which method will be called you need a contract
    - And for that you can use a Delegate

```` C#
// The problem with this code is that by adding more code to the Encode method logic, will mean that the whole
// VideoEncoder class and its children (or any other class that uses it), have to recompiled and redeployed, which
// could also possible create other problems in the code
public class VideoEncoder
{
    public void Encode(Video video){
        //Encoding logic
        // ...

        _mailService.Send(new Mail());
        _messageService.Send(new Text());
    }

    // Or

    // On this case the VideoEncoder class does not need to know anything about the MailService class
    // And if later you want to create a MessageService class, the VideoEncoder class and its children will not need to recompile
    // Making it faster do compile and deploy new features
    public void Encode(Video video){
        // Enconding logic
        // ...

        OnVideoEncoded();
    }
    
    public void OnVideoEncoded(object source, EventArgs e){
        
    }
}
````

```` C#
// This way, no matter how many notification services the VideoEncoder wants to use, the VideoEncoder class will never have to recompiled
// And also it is less tightly coupled with the MailService and MessageService class
// Which means you can create way more flexible and extensible code
// Other programmers only need to use what they want, they aren't dependent on your implementation 
public class Program(){
    public static void Main(){
        var video - new Video() { Title = "Video 1"};
        vara videoEncoder = new VideoEncoder(); // publisher
        var mailService = new MailService(); // subscriber
        var messageService = new MessageService(); // subscriber

        videoEncoder.VideoEncoded += mailService.OnVideoEncoded;
        videoEncoder.VideoEncoded += messageService.OnVideoEncoded;
        videoEncoder.Encode(video);
    }
}

// This forces you to send a Video object in the event, otherwise the code won't compile
// Which means you can't simply send an empty argument through the event
public class VideoEventArgs : EventArgs
{
    public Video video { get; set; }
}

public class VideoEncoder{
    // 1 - Define a delegate
    // 2 - Define an event based on that delegate
    // 3 - Raise the event

    public delegate void VideoEncodedEventHandler(object source, VideoEventArgs args);
    public event VideoEncodedEventHandler VideoEncoded;

    public void Encode(Video video){
        // Implementation
        OnVideoEncoded(video);
    }

    protected virtual void OnVideoEncoded(Video video){
        if (VideoEncoded != null)
            VideoEncoded(this,  new VideoEventArgs(){ Video = video  });
    }
}

Public class MailService{
    // This is the event handler.
    public void OnVideoEncoded(object source, VideoEventArgs e){
        Console.WriteLine("MailSerive: Sending an email... ") + e.Video.Title;
    }
}

public class MessageService{
    public void OnVideoEncoded(object source, VideoEventArgs e){
        Console.WriteLine("MessageService: Sending a message... " + e.Video.Title);
    }
}

````

## [Extension Methods](https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-and-call-a-custom-extension-method)
Allow us to add methods to an existing class without
- Changing its source code
- creating a new class that inherits from it

Useful for adding methods for sealed classes
It is very rare to create Extension Methods, it is more likely that you will have to use them from the frameworks.

```` C#
class Program{
    static void Main(){
        var shortenedPost = post.Shorten(s);
    }
}

public static class StringExtensions{
    // The this String argument represents the actual object we are applying this method on.
    public static string Shorten(this String str, int numberOfWords){
        if (numberOfWords == 0)
            return "";

        var word = str.Split(' ');
        
        if (words.Length <= numberOfWords)
            return str;

        return string.Join(" ", words.Take(numberOfWords));
    }
}
````

## [LINQ](https://docs.microsoft.com/dotnet/csharp/programming-guide/concepts/linq/)
- LINQ mean -> Language Integrated Query
- Gives you the capability to query objects


     <img alt="LINQ | Relation"  src="https://docs.microsoft.com/pt-br/dotnet/framework/data/adonet/media/dpue-linqtoadonetoverview-bpuedev11.gif"/>

```` C#
public class BookRepository{
    pubic IEnumerable<Book> GetBooks(){
        return new List<Book>{
            new Book() {Title = "ADO.NET Step by Step", Price = 5 },
            new Book() {Title = "ASP.NET MVC", Price = 9.99f  },
            new Book() {Title = "ASP.NET Web API", Price = 12.5f},
            new Book() {Title = "C# Advanced Topics", Price = 7},
            new Book() {Title = "C# Advanced Topics", Price = 9}
        };
    }
}

public class Program{
    public static void Main(){
        var books = new BookRepository();

        // LINQ Extension Methods
        var cheapBooks = books.Where(b => b.Price < 10);
        var orderedBooks = books.OrderBy(b => b.Title);

        var cheapOrderedBooks = books.Where(b => b.Price < 10)
                                                             .OrderBy(b => b.Title)
                                                             .Select(b => Title);

        var book = books.SingleOrDefault( b => b.Title == "ASP.NET MVC");

        var pagedBooks = books.Skip(2).Take(3);

        var count = books.Count();

        var maxPrice = books.Max(b => b.Price);
        var minPrice = books.Min(b => b.Price);
        var totalPrice = books.Sum(b => b.Price);

        // LINQ List of Methods
        .Where();
        .Single();
        .SingleOrDefault();
        
        .First();
        .FirstOrDefault();

        .Last();
        .LastOrDeault();

        .Min();
        .Max();
        .Count();
        .Sum();
        .Average();

        .Skip().Take();

        // LINQ Operators
        var cheapOrderedBooks = from b in books
                                                   where b.Price < 10
                                                   orderBy b.Title
                                                   select b.Title;


    }
}
````

## [Nullable Types](https://docs.microsoft.com/dotnet/csharp/language-reference/builtin-types/nullable-value-types)
- Value types cannot usually be null
  - But sometimes it does make sense to have a value type that can be null

```` C#
public class Program{
    public static void Main()
    {
        DateTime? date = null;
        DateTime checkedDate = date ?? DateTime.Today;  
    }
}
````

## [Dynamic](https://docs.microsoft.com/dotnet/csharp/programming-guide/types/using-type-dynamic)
Programming languages can be:
- Statically-typed languages: C#, Java
- Dynamically-typed languages: Runy, JavaScript, Python 

Type Resolution:
- Static Language: at Compile-time
- Dynamic languages: at run-time

Benefits
- Static languages: early feedback (compile-time)
- Dynamic languages: easier and faster to code

C# History
- Started as a static language
- .NET 4 added the dynamic capability, to improve interoperability with
  - COM (eg. writing office applications)
  - Dynamic languages (IronPython)

Without Dynamic you have to use reflection, which is a way to check the metadata of a type and access properties and methods
```` C#
class Program{
    static void Main(){

        // This is an example of using reflection 
        object obj = "Mosh";
        var methodInfo = obj.GetType().GetMethod("GetHashCode");
        methodInfo.Invoke(null, null);

        // This is an example of using Dynamic
        // You can do whatever you want with dynamic types and there will be no compile-error
        // However you need to do more Unit Tests to be sure the 
        dynamic excelObject = "mosh";
        excelObject.Optimize();
    }
}
````

## [Exception Handling](https://docs.microsoft.com/dotnet/csharp/programming-guide/exceptions/creating-and-throwing-exceptions)
An Exception is a error that occurs at runtime. If your code is I/O Bound, it is very important to catch those exceptions in order to explain the error to the user. Or treat the Exception in any way you want.

It is important to order your catch from more specific to more generic, this way you can be sure you will catch the more specific exception.
```` C#
class Program{
    static void Main(){
        var streamReader = new StreamReader(@"c:\file.zip");
        try{
            var content = streamReader.ReadToEnd();
        }
        catch (Exception ex){
            Console.WriteLine("Sorry, an unexpected error has occured.");
        }
        finally{
            streamReader.Dispose();
        }
    }
} 

// Another example
class Program{
    static void Main(){
        try{
            using (var streamReader = new StreamReader(@"c:/file;zip")){
                var content = streamReader.ReadToEnd();
            }
        }
        catch (Exception ex){
            Console.WriteLine("Sorry, an unexpected error occurred.");
        }
    }
}

// Another example
public class YouTubeException : Exception{
    public YouTubeException(string message, Exception innerException) : base(message, innerException){
    }
}

public class YoutubeAPI{
    public List<Video> GetVideos(string user){
        try{
            // Access YouTube web service
            // Read the Data
            // Create a list of video objects
            
        }
        catch (Exception ex){
            // Log it somewhere
            throw new YouTubeException("Could not fetch the videos from YouTube");
        }

        return new List<Video>();
    }
}
````

## [Async / Await](https://docs.microsoft.com/dotnet/csharp/language-reference/operators/await)
- Synchronous Program Execution
  - Program is executed line by line, one at a time
  - When a function is called, program execution has to wait until the function returns.
 
- Asynchronous Program Execution
  - When a function is called, program execution continues to the next line, without waiting for the function to complete

- When to use Asynchronous?
  - Accessing the Web
  - Working with files and databases
  - Working with images

- How to use Asynchronous?
  - Traditional Approaches:
    - Multithreading
    - Callbacks
  - New Approach since NET 4.5
  - Async / Await

# Big O

# Data Structures
## Arrays
## Hash Tables
## Linked Lists
## Stacks + Queues
## Trees
## Graph

# Algorithms
## Sorting
## Searching
## Dynamic Programming

# Design Patterns

## SOLID
SOLID is a group of five Principles that are very important for object-oriented programming, since they help you build more flexible and scalable code.

### [**Single Responsability Principle**](https://medium.com/@learnstuff.io/single-responsibility-principle-ad3ae3e264bb)


 <img alt="Single Responsability Principle" height="240px" src="https://miro.medium.com/max/2732/1*UhvaCg9qOCYZyDJZh180hQ.png"/>

````
A class should have one and only one reason to change, meaning that a class should have only one job.
````
```` C#
public class Journal
{
    private readonly List<string> entries = new List<string>();
    private static int count = 0;

    public int AddEntry(string text)
    {
        entries.Add($"{++count}: {text}");
        return count;
    }
 
    public void RemoveEntry(int index)
    {
        entries.RemoveAt(index);
    }

    public override string ToString()
    {
        return string.Join(Environment.NewLine, entries);
    }

    // Here the class gains more than one responsability
    // Not only it has to take care of all the Journal entries implementation
    // But it also has the responsability to manage the file in which it will be saved/loaded (called persistence)
    // Instead of doing this you should follow the Single Responsability Principle and have another class to deal with the persistence
    public void Save(string fileName){
        FileWriteAllText(fileName, ToString());
    }

    public static Journal Load(string fileName)
    {
        // Loads the journal
    }

    public void Load(Uri uri)
    {
        // Loads from an URI
    }
}

// Better way to deal with Persistence
// This creates a separation of concerns, the Journal class is concerned with keeping entries
// And the Persistence class in concerned with persistence those entries in a file
public class Persistence
{
    public void SaveToFile(Journal j, string fileName, bool overwrite = false)
    {
        if (overwrites || !File.Exists(fileName))
            File.WriteAllText(fileName, j.ToString());
    }
}


public class Demo
{
    static void Main()
    {
        var j = new Jornal();
        j.AddEntry("I cried today");
        j.AddEntry("I ate a bug...");
        Console.WriteLine(j);

        var p = new Persistence();
        var fileName = "some file path";
        p.SaveToFile(j, fileName, true);
        Process.Start(fileName);
    }
}
````

### [**Open-Closed Principle**](https://medium.com/@learnstuff.io/open-close-principle-442ebafb3528)

 <img alt="Open-Closed Principle" height="240px" src="http://www.cs.sjsu.edu/faculty/pearce/modules/lectures/ood/principles/ocp_files/image002.jpg"/>

````
Objects or entities should be open for extension but closed for modification.
````
```` C#
public enum Color
{
    Red, Green, Blue
}

public enum Size
{
    Small, Medium, Large, Huge
}

public class Product
{
    public string Name;
    public Color Color;
    public Size size;

    public Product(string name, Color color, Size size)
    {
        if  (name == null)
        {
            throw new ArgumentNullException(paramName: nameof(name));
        }
        Name = name;
        Color = color;
        Size = size;
    }
}

// This is breaking the open-closed principle
public class ProductFilter
{
    public IEnumerable<Product> FilterBySize(IEnumerable<Product> products, Size size)
    {
        foreach (var p in products)
            if (p.Size == size)
                yield return p;
    }

    public IEnumerable<Product> FilterByColor(IEnumerable<Product> products, Color color)
    {
        foreach (var p in products)
            if(p.Color == color) 
                yield return p;
    }

    public IEnumerable<Product> FilterBySizeAndColor(IEnumerable<Product> products, Color color, Size size)
    {
        foreach (var p in products)
            if(p.Color == color && p.Size == size) 
                yield return p;
    }
}

public interface ISpecification<T>
{
    bool IsSatisfied(T t);
}

public interface IFilter<T>
{
    IEnumerable<T> Filter(IEnumerable<T> items, ISpecification<T> spec);
}

public class ColorSpecification : ISpecification<Product>
{
    private Color _color;
    public ColorSpecification(Color color)
    {
        _color = color;
    }

    public bool IsSatisfied(Product t)
    {
        return t.Color == _color;
    } 
}

public class SizeSpecification : ISpecification<Product>
{
    private Size _size;
    public SizeSpecification(Size size)
    {
        _size = size;
    }

    public bool IsSatisfied(Product t)
    {
        return t.Size == _size;
    }
}

public class AndSpecification<T> : ISpecification<T>
{
    private ISpecification<T> _first, _second;

    public AndSpecification(ISpecification<T> first, ISpecification<T> second)
    {
        _first = first ?? throw new ArgumentNullException(paramName: nameof(first));
        _second = second ?? throw new ArgumentNullException(paramName: nameof(second));
    }
    public bool IsSatisfied(T t)
    {
        return first.IsSatisfied(t) && second.IsSatisfied(t);
    }

}

// You will never have to enter this class again to modify it, since you can send any specification through it
// This way it is closed for modification
// However, since you can always create more classes that implements ISpecification, it is open for extension
public class BetterFilter : IFilter<Product>
{
    public IEnumerable<Product> Filter(IEnumerable<Product> items, ISpecification<Product> spec)
    {
        foreach (var i in items)
            if (spec.IsSatisfied(i))
                yield return i;
    }
}

public class Demo
{
    static void Main()
    {
        var apple = new Product("Apple", Color.Green, Size.Small);
        var tree = new Product("Tree", Color.Green, Size.Large);
        var house = new Product("House", Color.Blue, Size.Large);

        Product[] products = {apple, tree, house};

        // Not using the open-closed principle, you have to use a specific filter from the ProductFilter class
        // in order to filter something
        var pf = new ProductFilter();
        WriteLine("Green products (old): ");
        foreach (var p in pf.FilterByColor(products, Color.Green)){
            WriteLine($" - {p.Name} is green");
        }

        var bf = new BetterFilter();
        WriteLine("Green Products (new): ");
        foreach (var p in bf.Filter(products, new ColorSpecification(Color.Green))
        {
            WriteLine($" - {p.Name} is green");
        }

        // Using open-closed principle
        // This way you can have as many filters as you want on the same list
        // You can also create a class that recieves a list of specifications, instead of only having two
        WriteLine("Large Blue Products: ");
        foreach(var p in bf.Filter(product, 
                    new AndSpecification<Product>(
                        new ColorSpecification(Color.Blue),
                         new SizeSpecification(Size.Large))))
        {
            WriteLine($" - {p.Name} is Large and Blue");
        }
    }
}
````

### [**Liskov Substitution Principle**](https://medium.com/@learnstuff.io/liskov-substitution-principle-ad0d6a51ffb0)

 <img alt="Liskov Substitution Principle" height="240px" src="https://miro.medium.com/max/1050/1*iV_TeHoEDE0TwhQEFj2fxA.png"/>

```` 
Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.
Or -> You should be able to substitute a base for a subtype. 
````

```` C#
public class Rectangle
{
    // This is the wrong way of doing it if you desire to override it's behavior on a child class
    // public int Width { get; set; }
    // public int Height { get; set; }

    public virtual int Width { get; set; }
    public virtual int Height { get; set; }

    public Rectangle(int width, int height)
    {
        Width = width;
        Height = height;
    }

    public override string ToString()
    {
        return $"{nameof(Width)}: {Width}, {nameof{Height}: {Height}}";
    }
}

/// Instead of using the new keyword, if you wish to have a child class of Rectangle with different behavior,
// you should use the virtual keyword on the values you wish to change the behavior of
public class Square : Rectangle
{
    // public new int Width
    // {
    //     set { base.Width = base.Height = value; }
    // }

    // public new int Height
    // {
    //     set { base.Height = base.Width = value; }
    // }


    // By using the virtual and override keyword, when you create a instace of type Rectangle with a reference to a Square type
    // The compiler will check and see that the values are virtual and then search their actual implementation and the child class
    public override int Width
    {
        set { base.Width = base.Height = value; }
    }

    public override int Height
    {
        set { base.Height = base.Width = value; }
    }
}

public class Demo
{
    static public int Area(Rectangle rec) => rec.Width * rec.Height;

    public static void Main()
    {
        var rec = new Rectangle(3, 4);
        Console.WriteLine($"{rec} has area {Area(rec)}");
    }
}
````

### [**Interface Segregation Principle**](https://medium.com/@learnstuff.io/interface-segregation-principle-dd885e59aec9)

 <img alt="Interface Segregation Principle" height="240px" src="https://miro.medium.com/max/1050/1*YzBpqn1XSHOz9UpKc6HcJg.png"/>


````
A client should never be forced to implement an interface that it doesn’t use.
Or clients shouldn’t be forced to depend on methods they do not use.
````

```` C#
public class Document
{

}

public interface IMachine
{
    void Print(Document doc);
    void Scan(Document doc);
    void Fax(Document doc);
}

public class MultifunctionPrinter : IMachine
{
    public void Print(Document doc)
    {
        // Implements something
    }

    public void Scan(Document doc)
    {
        // Implements something
    }

    public void Fax(Document doc)
    {
        // Implements something
    }
}

// This breaks the Interface segregation principle, because it is forcing you to implement methods that aren't going to be used
public class PrintOnlyPrinter : IMachine
{
    public void Print(Document doc)
    {
        // Implements something
    }

    public void Scan(Document doc)
    {
        // This printer does not have the Scan capability, however the interface forces the class to implement it
        // So you need to throw an error, or create a no-op, however you don't want methods without implementation on your classes
    }

        public void Fax(Document doc)
    {
        // Implements nothing...
    }
}

public interface IPrinter
{
    void Print(Document doc);
}

public interface IScanner
{
    void Scan(Document doc);
}

public interface IFax
{
    void Fax(Document doc);
}

public class Photocopier : IPrinter, IScanner
{
    public void Print(Document doc)
    {
        // Implements something
    }

    public void Scanner(Document doc)
    {
        // Implements something
    }
}

public interface IMultiFunctionDevice : IScanner, IPrinter, IFax
{
}

public class MultiFunctionMachine : IMultifunctionDevice
{
        public void Print(Document doc)
    {
        // Implements something
    }

    public void Scan(Document doc)
    {
        // Implements something
    }

    public void Fax(Document doc)
    {
        // Implements something
    }
}
````

### [**Dependency Injection Principle**](https://medium.com/@learnstuff.io/dependency-inversion-principle-aafa06af26b4)
<img alt="Dependency Injection Principle" height="240px" src="https://miro.medium.com/max/1050/1*b6EH_TCw1gEvhGe8eT4VTg.png"/>

````
Entities must depend on abstractions, not on concretions. 
It states that the high-level module must not depend on the low-level module,
but they should depend on abstractions.

Or -> high level parts of the system should not depend on low level part of the system directly,
 instead it should depend on some sort of abstration
````

```` C#
public enum Relationship
{
    Parent,
    Child,
    Sibling
}

public class Person
{
    public string Name;
}

public class Relationships : IRelationshipBrowser
{
    private List<(Person, RelationShip, Person)> _relations = new List<(Person, Relationship, Person)>();

    public void AddParentAndChild(Person, parent, Person child)
    {
        _relations.Add(parent, RelationShip.Parent, child);
        _relations.Add(child, RelationShip.Child, Parent);
    }

     public IEnumerable<Person> FindAllChildrenOf(string name)
     {
         foreach (var r in relations.Where(
             x => x.Item1.Name -- name &&
             x.Item2 == Relationship.Parent
         ))
         {
             yield return r.Item3;
         }
     }

   // public List<(Person, Relationship, Person)> Relations => relations;
}

public class Research
{

    // The problem is that we are accessing a very low level part of the Relationship class, we are accessing its data store
    // And accessing it through a specific design, which exposes the private field as public.
    // And the Relationship class should not change its way of storing relationships, because if it does change, it will break this
    // Research class
    // public Research(Relationships relationships)
    // {
    //     var relations = relationships.Relations;
    //     foreach (var r in relations.Where(
    //         x => x.Item1.Name == "Zeus" &&
    //                 x.Item2 == Relationship.Parent
    //     ))
    //     {
    //         Console.WriteLine($"Zeus has a child called {r.Item3.Name}");
    //     }
    // }

    public Research(IRelationshipBrowser browser)
    {
            foreach (var p in browser.FindAllChilderOf("Zeus"))
                Console.WriteLine($"Zeus has a child called {p.Name}");
    }
}

public interface IRelationshipBrowser
{
    IEnumerable<Person> FindAllChildrenOf(string name);
}

public class Demo{
    static void Main()
    {
        var parent = new Person { Name = "Zeus" };
        var child1 = new Person { Name = "Afrodite" };
        var child2 = new Person { Name = "Apolo" };

        var rel = new Relationships();
        rel.AddParentAndChild(parent, child1);
        rel.AddParentAndChild(parent, child2);

        var res = new Research(rel);
    }
}
````

### Summary
- Single Responsability Principle
  - A class should only have one reason to change
  - Separation of concerns - different classes handling different, independent taks/problems
- Open-Closed Principle
  - Classes should be open for extension but closed for modification
- Liskov Substitution Principle
  - You should be able to substitute a base type for a subtype
- Interface Segregation Principle
  - Don't put too much into an interface; split into separate interface
  - YAGNI - You Ain't Going to Need It
- Dependency Injection Principle
  - High-level modules should not depend upon low-level ones; use abstractions.

## Gamma Categorization
- Design Patterns are Typically into three categories
- This is called Gamma Categorization after Erich Gamma, one of the GoF authors

- **Creational Patterns**
  - Deal with the creation (construction) of objects
  - Explicit (constructor) vs. implicit (DI, reflection, etc.)
  - Wholesale (single statement) vs. piecewise (step-by-step)
- **Structural Patterns**
  - Concerned with the structure (e.g. class members)
  - Many patterns are wrappers that mimic the underlying class' interface
  - Stress the importance of good API Design
- **Behavioral Patterns**
  - They are all different; They have no central theme.

# Creational Patterns
## [Builder](https://refactoring.guru/design-patterns/builder)

<img alt="Builder Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/builder/builder-en-2x.png"/>

- Motivation
  - Some objects are simple and can be created in a single constructor call
  - Other objects require a lot of ceremony to create
  - Having an object with 10 contructor arguments is not productive
  - Instead, opt for piecewise contruction
  - Builder provides an API for constructing an object step-by-step

- Example without using Builder
```` C#

public class Demo
{
    // The problem here is that we are building an HTML without the correct formating 
    // Something that could be on a separate class
    static void Main()
    {
        var hello = "hello"
        var sb = new StringBuilder();
        sb.Append("<p>");
        sb.Append(hello);
        sb.Append("</p>");
        Console.WriteLine(sb);

        var words = new[] {"hello", "world"};
        sb.Clear();
        sb.Append("<ul>")/
        foreach (var word in words)
        {
            sb.AppendFormat(<li>{0}</li>", word)
        }
        sb.Append("</ul>");
        Console.WriteLine(sb);
    }
}
````

- Now using the Builder to construct the HTML
```` C#
public class HtmlElement
{
    public string Name, Text;
    public List<HtmlElement> Elements = new List<HtmlElement>();
    private const int indentSize = 2;

    public HtmlElement() {}

    public HtmlElement(string name, string text)
    {
        Name  = name ?? throw new ArgumentNullException(paramName: nameof(name));
        Text = text ?? throw new ArgumentNullException(paramName: nameof(text));
    }

    private string ToStringImpl(int indent){
        var sb = new StringBuilder();
        var i = new string(' ', indentSize * indent);
        sb.Append($"{i}<{name}>");
        if (!string.IsNullOrWhiteSpace(Text))
        {
            sb.Append(new string(' ', indentSize * (indent + 1)));
            sb.AppendLine(Text);
        }

        foreach (var e in Elements)
        {
            sb.Append(e.ToStringImpl(indent + 1));
        }
        sb.AppendLine($"{i}</{name}>");
        return sb.ToString();
    }

    public override string ToString()
    {
        return ToStringImpl(0);
    }
}

public class HtmlBuilder
{
    private readonly string _rootName;
    HtmlElement root = new HtmlElement();

    public HtmlBuilder(string rootName)
    {
        _rootName = rootName;
        root.Name = rootName;
    }

    public HtmlBuilder AddChild(string childName, string childText)
    {
        var e = new HtmlElement(childName, string childText);
        root.Elements.Add(e);
        return this;
    }

    public override string ToString()
    {
        return root.ToString();
    }
    
    public void Clear()
    {
        root = new HtmlElement()
    }
}


public class Demo
{
    public static void Main()
    {
            var builder =  new HtmlBuilder("ul");
            builder.AddChild("li", "Hello")
                       .AddChild("li", "world");

            Console.WriteLine(builder);
    }
}
````

### Fluent Builder
- When a builder returns the object its doing the operation on, you can chain calls for the builder method, this is called fluent builder.

#### [Fluent builder Inheritance with Recursive Generics](https://code-maze.com/fluent-builder-recursive-generics/)
The problem of inheriting Fluent Builders, is that when you call a method from a parent class, it doest not return the builder type you created the variable with. And when this happen, you can't use the child class's methods anymore.

```` C#
public class PersonInfoBuilder
{  
    protected Person person = new Person();

    public PersonInfoBuilder Called(string name)
    {
        person.Name = name;
        return this;
    }
}


public class PersonJobBuilder : PersonInfoBuilder
{
    public PersonJobBuilder WorkAsA(string position)
    {
        person.Position = position;
        return this;
    }
}

public class Program
{
    public static void Main()
    {
        // The problem here ia that when you call the method Called, it will return a PersonInfoBuilder,
        // and then you are trying to call the method WorkAsA in an object that does not have that method, because it is of type
        // PersonInfoBuilder instead of PersonJobBuilder. And thus, you need to use something to be sure that PersonInfoBuilder will
        // return its child, and not itself
        var builder = new PersonJobBuilder();
        builder.Called("Luke")
                    .WorkAsA("Developer");
    }
}
````

```` C#
public class Person
{
    public string Name;
    public string Position;


    // Here we create this Builder API in order to use the Builders without the need to instantiate it somehere, since the SELF type is not very clear
    // So we have this class that inherits from the class that inherits from all other classes
    public class Builder : PersonJobBuilder<Builder>
    {

    }

    // And here we are able to create a new Builder everytime we call for new, and since the class Builder can create and return
    // a new Person variable, we can assentialy use the Person class to create as many Persons as we want, using Fluent Builders with Recursive Generics
    public static Builder New => new Builder();

    public override string ToString()
    {
        return $"{nameof(Name)}: {Name}, {nameof(Position)}, {Position}";
    }
}


class PersonBuilder
{
    protected Person person = new Person();

    public Person Build()
    {
        return person;
    }
}

// Called methods need to return a generic type, therefore our calass is generic as well.
// It needs to inherit from the PersonBuilder class because we need that Person object.
// We must also make sure to get the right type fot the SELF type in our class. 
// And we can achieve this by restricting our SELF type to the PersonInfoBuilder type;
public class PersonInfoBuilder<SELF> 
: PersonBuilder 
where SELF : PersonInfoBuilder<SELF>
{
    public SELF Called(String name)
    {
        person.Name = name;
        return (SELF) this;
    }
}

// We follow the PersonBuilder approach here, so that we can also inherit from this class in the future
public class PersonJobBuilder<SELF> 
: PersonInfoBuilder<PersonJobBuilder<SELF>>
where SELF : PersonJobBuilder<SELF>
{
    public SELF WorkAsA(string position)
    {
        person.Position = position;
        return (SELF) this;
    }
}

// There is another problem, we can't simply create a PersonJobBuilder variable anymore, because it is not clear which type
// SELF should be in this case, so we need a mechanism inside Person in order to work around this problem
public class Program
{
    public static void Main()
    {
        var me = Person.New.Called("Luke").WorkAsA("Developer").Build();
        Console.WriteLine(me);
    }
}
````

### Functional Builder
When you are trying to create a builder in a more functional setting, it's important to adhere to SOLID principle, so how can we do what we did previously using the Open-Closed Principle

```` C#
public class Person
{
    public string Name, Position;

    public override string ToString()
    {
        return $"{nameof(Name)}: {Name}, {nameof(Position)}: {Position}";
    }
}

public sealed class PersonBuilder
{
    private readonly List<Func<Person, Person>> actions = 
    new List<Func<Person, Person>>();

    public Person Build() =>
        actions.Aggregate(new Person(), (p, f) => f(p));

    public PersonBuilder Do(Action<Person> action) => AddAction(action);

    // The reason why we are taking an Action and turning it into a Func is because 
    // we want to preserve the Fluent Builder interface, and the reason why you want
    // to preserve a Fluent interface is because at some point we might want to use
    // the aggregate link method in order to Apply all the funcions one after another
    private PersonBuilder AddAction(Action<Person> action)
    {
        actions.Add(p => { action(p); 
            return p;
        });
        return this;
    }
}

úblic static class PersonBuilderExtensions
{
    public static PersonBuilder Called(this PersonBuilder builder, string name) 
        => builder.Do(p => p.Name = name);

    public static PersonBuilder WorkAsA(this PersonBuilder builder, string position) 
        => builder.Do(p => p.Name = name);
}

public class Program
{
    public static void Main()
    {
        var person = new PersonBuilder();
        // This here is adding to the list of Func inside PersonBuilder, and when you use Build, 
        // they are going to be called one after another
        person.Called("Luke").WorkAsA("Developer");
        Console.WriteLine(person.Build());
    }
}
````

#### Generic Functional Builder
As seen before, we can have a sealed builder and use Extension Methods to add different methods to the Builder without breaking the Open-Closed Principle.
However we could generalize the Builder class in order to reuse the code.
```` C#
public class Person
{
    public string Name, Position;

    public override string ToString()
    {
        return $"{nameof(Name)}: {Name}, {nameof(Position)}: {Position}";
    }
}

// This class is abstract and therefore cannot be instantiated
// When inheriting from this class you can pass the TSubject (class you want to do the operations on)
// And TSelf (The name of the class itself), and then you can use Extension Methods to add
// More actions to the class
public abstract class FunctionalBuilder<TSubject, TSelf>
    where TSelf : FunctionalBuilder<TSubject, TSelf>
    where TSubject : new()
{   
    private readonly List<Func<TSubject, TSubject>> actions = 
        new List<Func<TSubject, TSubject>>();

    public TSelf Do(Action<TSubject> action)
        => AddAction(action);

    public TSubject Build()
        => actions.Aggregate(new TSubject(), (p, f) => f(p));

    private TSelf AddAction(Action<TSubject> action)
    {
        actions.Add(p => { action(p);
        return p;
        });
        return (TSelf) this;
    }
}

public sealed class PersonBuilder 
    : FunctionalBuilder<Person, PersonBuilder>
{
    public PersonBuilder Called(string name)
        => Do(p => p.Name = name);
}

public static class PersonBuilderExtensions
{
    public static PersonBuilder WorkAsA(this PersonBuilder builder, string position)
        => builder.Do(p => p.Name = name);

}

public class Program
{
    public static void Main()
    {
        var person = new PersonBuilder();
        person.Called("Luke")
        .WorkAsA("Developer");
        Console.WriteLine(person.Build());
    }
}
````

### Faceted Builder
Until so far we have only used one builder for each class, however sometimes a class need more than one builder
```` C#
// Since we have multiple field related to different things about a person, it makes sense that we create different Builders,
// Each for a different subject.
public class Person
{
    // address
    public string StreetAddress, PostCode, City;

    // Empoyment
    public string CompanyName, Position;
    public int AnnualIncome;

    // Personal
    public string FirstName, LastName;
    public int Age;

    public override string ToString()
    {
        return $"{nameof(StreetAddress)}: {StreetAddress}, {nameof(PostCode)}: {PostCode}, {nameof(City)}: City \n" +
                    $"{nameof(CompanyName)}: {CompanyName}, {nameof(Position)}: {Position}, {nameof(AnnualIncome)}: {AnnualIncome}\n" +
                    $"{nameof(FirstName)}: {FirstName}, {nameof(LastName)}: {LastName}, {nameof(Age)}, {Age}";

    }
}

public class PersonBuilder //Façade
{
    protected Person person = new Person();

    public PersonJobBuilder Works => new PersonJobBuilder(person);
    public PersonAddressBuilder Lives => new PersonAddressBuilder(person);
    public PersonPersonalBuilder Is => new PersonPersonalBuilder(person);

    public static implicit operator Person(PersonBuilder pb)
    {
        return pb.person;
    }
}

public class PersonAddressBuilder : PersonBuilder
{
    public PersonAddressBuilder(Person person)
    {
        this.person = person;
    }

    public PersonAddressBuilder At(string streetAddress){
        person.StreetAddress = streetAddress;
        return this;
    }

    public PersonAddressBuilder In(string city)
    {
        person.City = city;
        return this;
    }

    public PersonAddressBuilder WithPostCode(string postCode)
    {
        person.PostCode = postCode;
        return this;
    }
}

public class PersonJobBuilder : PersonBuilder
{
    public PersonJobBuilder(Person person)
    {
        this.person = person;
    }

    public PersonJobBuilder At(string companyName){
        person.CompanyName = companyName;
        return this;
    }

    public PersonJobBuilder AsA(string position)
    {
        person.Position = position;
        return this;
    }

    public PersonJobBuilder Earning(int amount)
    {
        person.AnnualIncome = amount;
        return this;
    }
}

public class PersonPersonalBuilder : PersonBuilder
{
    public PersonPersonalBuilder(Person person)
    {
        this.person = person;
    }

    public PersonPersonalBuilder Called(string name)
    {
        person.FirstName = name;
        return this;
    }

    public PersonPersonalBuilder CalledLast(string name)
    {
        person.LastName = name;
        return this;
    }

    public PersonPersonalBuilder Age(int age)
    {
        person.Age = age;
        return this;
    }
}

public class Demo
{
    public static void Main()
    {
        var pb = new PersonBuilder();
        Person person = pb
            .Lives
                .At("Figueiredo Magalhães")
                .In("Rio de Janeiro")
                .WithPostCode("22031011")
            .Works
                .At("Stone")
                .AsA("Developer")
                .Earning(30000)
            .Is
                .Called("Luke")
                .CalledLast("Dias")
                .Age(21);
    }
}
````


## [Factories](https://refactoring.guru/design-patterns/factory-method) 

<img alt="Factory Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/factory-method/factory-method-en-2x.png"/>

- Motivations
  - Object creating logic becomes too convoluted
  - Constructor is not descriptive
    - Name mandated by name of containing type
    - Cannot overload with same sets of arguments with different names
    - Can turn into 'optional parameters hell'
  - Object creation (non-piecewise, unlike Builder) can be outsourced to
    - A separate function (Factory Method)
    - That may exist in a separate class (Factory)
    - Can create hierarchy of factories with Abstract Factory

- Factory is a component responsible solely for the wholesale (not piecewise) creation of objects.

- Example of that can go wrong when not using Factories
```` C#
public enum CoordinateSystem{
    Cartesian, Polar
}

public class Point
{
    private double x, y;
    

    public Point(double a, double b, CoordinateSystem system = CoordinateSytem.Cartesian)
    {
        switch (system)
        {
            case CoordinateSystem.Cartesian:
                x = a;
                y = b;
                break;
            case CoordinateSystem.Polar:
                x = a * Math.cos(b);
                y = a * Math.sin(b);
                break;
            default:
                throw new ArgumentOutOfrangeException();
        }
        this.x = x;
        this.y = y;
    }

    // You cannot have two contructors with the same signature
    // Even though it does make sense to create the points through theta and rho,
    // And thus if you need this constructor to exist somehow you could do what
    // Is being done above, however it creates many different problems
    // Such as a and b being very generic and hard to know what it represents
    // And if you create a XML comment it could happen that the person using it does not read it
    // And it would still be not easy to read the code
    public Point( double rho, double theta){
        // Some implementations
    }
}
````

- Now using Façade to avoid those problems
```` C#
public class Point
{

    private double x, y;

    public Point(double x, double y)
    {
        this.x = x;
        this.y = y;
    }
}
````
## [Singleton](https://refactoring.guru/design-patterns/singleton)

<img alt="Singleton Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/singleton/singleton-2x.png"/>

# Structural Patterns
## [Adapter](https://refactoring.guru/design-patterns/adapter)

<img alt="Adapter Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/adapter/adapter-en-2x.png"/>

## [Bridge](https://refactoring.guru/design-patterns/bridge)

<img alt="Bridge Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/bridge/bridge-2x.png"/>

## [Composite](https://refactoring.guru/design-patterns/composite)

<img alt="Composite Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/composite/composite-2x.png"/>

## [Decorator](https://refactoring.guru/design-patterns/decorator)

<img alt="Decorator Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/decorator/decorator-2x.png"/>

## [Façade](https://refactoring.guru/design-patterns/facade)

<img alt="Façade Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/facade/facade-2x.png"/>

## [Flyweight](https://refactoring.guru/design-patterns/flyweight)

<img alt="Flyweight Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/flyweight/flyweight-2x.png"/>

## [Proxy](https://refactoring.guru/design-patterns/proxy)

<img alt="Builder Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/proxy/proxy-2x.png"/>

# Behavioral Patterns
## [Chain of Responsability](https://refactoring.guru/design-patterns/chain-of-responsibility)

<img alt="Chain of Responsability Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/chain-of-responsibility/chain-of-responsibility-2x.png"/>

## [Command](https://refactoring.guru/design-patterns/command)

<img alt="Command Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/command/command-en-2x.png"/>

## Interpreter



## [Iterator](https://refactoring.guru/design-patterns/iterator)

<img alt="Iterator Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/iterator/iterator-en-2x.png"/>

## [Mediator](https://refactoring.guru/design-patterns/mediator)

<img alt="Mediator Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/mediator/mediator-2x.png"/>

## [Memento](https://refactoring.guru/design-patterns/memento)

<img alt="Memento Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/memento/memento-en-2x.png"/>

## Null Object


## Observer(https://refactoring.guru/design-patterns/observer)

<img alt="Observer Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/observer/observer-2x.png"/>

## State(https://refactoring.guru/design-patterns/state)

<img alt="State Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/state/state-en-2x.png"/>

## [Strategy](https://refactoring.guru/design-patterns/strategy)

<img alt="Strategy Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/strategy/strategy-2x.png"/>

## [Template Method](https://refactoring.guru/design-patterns/template-method)

<img alt="Template Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/template-method/template-method-2x.png"/>

## [Visitor](https://refactoring.guru/design-patterns/visitor)

<img alt="Visitor Design Pattern" height="240px" src="https://refactoring.guru/images/patterns/content/visitor/visitor-2x.png"/>

# Refactoring

## Code Smells
Code smelss are key signs that refactoring is necessary. In the process of refactoring, we get rid of s,ells, enabling further development of the application with equal or greater speed.
The lack of regular refactoring can lead to a complete paralysis of a project over time, wastng a few years of development and requiring you to spend several more years to reqrite it from scratch.
Therefore, it is necessary to get rid of code smelss while they are still small.

### Bloaters
Bloaters are code, methods and classes that have increased to such gargantuan proportions that they are hard to work with.
Usually these semlls do not crop up right away, rather they accumulate over time as the program evolves (and specially when nobody makesan effort to eradicate them).

### Long Methods
A method contains too many lines of code (generally, any method that is longer than ten lines should make you start asking questions).

- Reasons for the problem
  - When things are being added, but nothing is ever taken out. Since it's easier to write code than to read it, this "smell" remains unnoticed until the method turns into an ugly, oversized beast.
  - Mentally, it's often harder to create a new method than to add to an existing one: "But it's just two lines, there's no use in creating a while method just for that..." Which means that another line is added and then yet another, giving birth  to a tangle of spaghetti code
- Treatment
  - As a rule of thumb, if you feel the need to comment on something inside a method, you should take this code and put it in a new method. Even a single line can and should be split off into a separate method, if it requires explanations. And if the method has a descriptive name, nobody will need to look at the code to see what it does.
#### Recipe #1
To reduce the length of a body, use Extract Method
- Problem 
  - You have a code fragment that can be grouped together.
- Solution 
  - Move this code to are separate new method and replace the old code with a call to the method
```` C#
// Problem
void PrintOwing()
{
    PrintBanner();

    // Print Details
    Console.WriteLine("name: " + name);
    Console.WriteLine("amount: " + Outstanding;
}

// Solution
void PrintOwing()
{
    PrintBanner();
    PrintDetails(Outstanding);
}

void PrintDetails(double outstanding)
{
    Console.WriteLine("name: " + name);
    Console.WriteLine("amount: " + outstanding);
}
````

#### Recipe #2
Reduce Local Variables and Parameters Before Extracting a Method
If local variables and parameters interfere with extracting a method, use Replace Temp with Query, Introduce Parameter Object or Preserve Whole Object.

- Replace Temp with Query
  - Problem
    - You place the result of an expression in a local variable for later use in your code
  - Solution
    - Move the entire Expression to a separate method and return the result from it. Query the method instead of using a variable.
    - Incorporate the new method in other methods, if necessary;
```` C#
// Problem
double CalculateTotal()
{
    double basePrice = quantity * itemPrice;

    if (basePrice > 1000)
        return basePrice * 0.95;
    else
        return basePrice * 0.98;
}

// Solution
double CalculateTotal()
{
    if (BasePrice() > 1000)
        BasePrice() * 0.95;
    else
        BasePrice() * 0.98;
}

double BasePrice() 
    => quantity * itemPrice;
````

- Introduce Parameter Object
  - Problem
    - Your methods contain a repeating group of parameters
  - Solution
    - Replace these parameters with an object

```` C#
// Problem
AmountInvoicedIn(DateTime start, DateTime end);
AmountReceivedIn(DateTime start, DateTime end);
AmountOverdueIn(DateTime start, DateTime end);

// Solution
AmountInvoicedIn(DateRange range);
AmountReceivedIn(DateRange range);
AmountOverdueIn(DateRange range);
````

- Preserve Whole Object
  - Problem
    - You get several values from an object and then pass them as parameters to a method
  - Solution
    - Instead, try passing the whole object

```` C#
// Problem
int low = dasTempRange.Low;
int high = daysTempRange.High;
bool withinPlan = plan.WithinRange(low, high);

// Solution
boolean withinPlan = plan.WithinRange(daysTempRange);
````

#### Recipe #3
Replace Method with Method Object
If none of the previous recipes help, try moving the entire method to a separate object via Replace Method with Method Object.
- Problem
  - You have a long method in which the local variables are so interwined that you can't apply Extract Method
- Transform the method into a separate class so that the local variables become fields of the class. Then you can split the method into several methods within the same calss.

```` C#
// Problem
class Order
{
    public double Price()
    {
        double primaryBasePrice;
        double secondaryBasePrice;
        double tertiaryBasePrice;
        // Perform long computation
    }
}

// Solution
class Order{
    public double Price()
    {
        return new PriceCalculator(this).Compute();
    }
}

class PriceCalculator
{
    private double primaryBasePrice;
    private double secondaryBasePrice;
    private double tertiaryBasePrice;

    public PriceCalculator(Order order)
    {
        // Copy relevant information from the order object 
    }

    public double Compute()
    {
        // Perform long computation
    }
}
````

#### Recipe 4#
Conditionals and Loops
Conditionals operators and loops are a good clue that code can be moved to a separate method. For conditionals, use Decompose Conditionals. If loops are in the way, try Extract Method.

- Conditionals
  - Problem
    - You have a complex conditional
  - Solution
    - Decompose the complicated parts of the conditional into separate methods: the condiction, else if and else;

```` C#
// Problem
if (date.Before(SUMMER_START) || date.After(SUMMER_END))
    charge = quantity * winterRate * winterServiceCharge;
else
    charge = quantity * summerRate;

// Solution
if (isSummer(date))
    charge = SummerCharge(quantity);
else
    charge = WinterCharge(quanity);
````

- Loops
  - Problem
    - You have a code fragment that can be grouped together
  - Solution
    - Move this code to a separate new method (or function) and replace the old code with a call to the method

```` C#
// Problem
void PrintProperties(List<User> users)
{
    for (var i = 0; i < users.Length; i++)
    {
        var result = new StringBuilder();
        result.Append(users[i].Name())
                 .Append(" ")
                 .AppendLine(users[i].Age());
        Console.WriteLine(result);
    }
}

// Solution
void PrintProperties(List<User> users)
{
    foreach (var user in user)
        Console.WriteLine(GetProperties(user))/
}

string GetProperties(User use)
{
    return $"{user.Name} - {user.Age}";
}
````

#### Payoff
Among all types of object-oriented code, classes with short methods live longest. The longer a method or function is, the harder it becomes to understand and maintain it.
In addition, long methods offer the perfect hiding place of unwanted duplicate code.
- Performace
  - Does an increase in numver of methods hurt performance, as many people clain? In almost all cases the impact is so negligible that it's not even worth worrying about.
  - Plus, now that you have clear and understandable code, you're more likely to find truly effective methods for restructuring code and getting real performance gains if the need ever arises.

### Large Class
A class that contains many fields/methods/lines of code.
- Reason for the Problem
  - Classes usually start small. But over time, they get bloated as the program grows.
  - As is the case with long methods as well, programmers usually find it mentally less taxing to place a new feature in an existing class than to create a new class for the feature... (it happens all the time, lol).
- Treatment
  - When a class is wearing too many (functional) gats, think about splitting it up.

#### Recipe 1#
Extract Class
Extract Class helps if part of the behavior of the large class can be spun off into a separate component.
- Problem
  - When one class does the work of two, awkwardness results.
- Solution
  - Instead, create a new class and place the fields and methods responsible for the relevant functionality in it.

```` C#
// Problem
class Person
{
    public string Name;
    public string OfficeAreaCode;
    public string OfficeNumber;
}

// Solution
class Person
{
    public string Name;
    public TelephoneNumber telephone;
}

class TelephoneNumber
{
    public string OfficeAreaCode;
    public string OfficeNumber;
}
````

#### Recipe #2
Extract Subclass
Extract Subclass helps if part of the behavior of the large class can be implemented in different ways or is used in rare cases.
- Problem
  - A class has features that are used only in certain cases


<img alt="Memento Design Pattern" height="240px" src="https://refactoring.guru/images/refactoring/diagrams/Extract%20Subclass%20-%20Before.png"/>


- Solution
  - Create a subclass and use it in these cases


<img alt="Memento Design Pattern" height="240px" src="https://refactoring.guru/images/refactoring/diagrams/Extract%20Subclass%20-%20After.png"/>

#### Recipe #3
Extract Interface
Extract Interface helps if it's necessary to have a list of the operations and behaviors that the client can use.
- Problem
  - Multiple clients are using the same part of a class interface.
  - Another case: part of the interface int two classes are the same

<img alt="Memento Design Pattern" height="240px" src="https://refactoring.guru/images/refactoring/diagrams/Extract%20Interface%20-%20Before.png"/>

- Solution
  - Move this identical portion to its own interface

<img alt="Memento Design Pattern" height="240px" src="https://refactoring.guru/images/refactoring/diagrams/Extract%20Interface%20-%20After.png"/>

#### Recipe 4#
Separate GUI and Domain Data
If a large class is responsible for the graphical interface. you may try to move some of its data and behavior to a separate domain object. In doing so, it may be necessary to store copies of some data in two places and keep the data consistent. Duplicate Observed Data offers a way to do this.
- Problem
  - Is domain data stored in classes responsible for the GUI.

<img alt="Memento Design Pattern" height="240px" src="https://refactoring.guru/images/refactoring/diagrams/Duplicate%20Observed%20Data%20-%20Before.png"/>

- Solution
  - Then it's a good idea to separate the data into separate classes, ensuring connection and synchronyzation between the domain class and the GUI.

<img alt="Memento Design Pattern" height="240px" src="https://refactoring.guru/images/refactoring/diagrams/Duplicate%20Observed%20Data%20-%20After.png"/>

#### Payoff
- Refactoring these classes spares developers from needing to remember a large number of attributes of a class.
- In many cases, splitting Large classes into parts avoid duplication of code functionality

### Primitive Obsession

# Multithreading 


## Asynchrony
Asynchrony refers to the occurece of events independent of the main program flow and ways to deal with such events.

## Thread
A thread of execution is the samllest sequence of programmed instructions that can be managed independently by a scheduler, which is typically a part of the operating system.

A thread is a component of a process. Multiple threads can exist within one process, executing concurrently and sharing resources such as memory.

- Thread are independent units which isolates sets of instructions from each other
- Thread has its own local storage called TLS or Thread Local Storage
- Any thread can exist only within a particular process and they can't migrate from one process to another
- One process can spawn many threads
  - While threadss isolate their own storages, they can easily share all the resources of an executing process such as heap memory.
- For asynchronous processing, we create and run nwe threads rather than processes

### ThreadPool and Scheduling
- Thread pool is a storage of threads which allocate them when requested by a running process
- Threads have to be scheduled by some sort of mechanism (Thread Scheduler)
- Thread Scheduler is responsible for allocating processing cores and running particular threads on them.

## Multithreading

## Parallel Computing
In parallel computing, execution occurs at the same physical instant: for example, on separate processors of a multi-processor machine, with the goal of speeding up computations - parallel computing is impossible on a (one-core) single processor, as only one computation can occur at any instant.

Parallel computing is a type of computation in which many calculations or the execution of processes are carried out concurrently. Large problems can often be divided into smaller ones, which can then be solved at the same time.

## Concurrency
Concurrent programs handle tasks that are all in progress at the same time, but is only necessary to work briefly and separately on each task. so the work can be interleaved in whatever order the tasks require.

Concurrent computing consists of process lifetimes overlapping, but execution need not happen at the same instant. The goal here is to model processors in the outside world that happen concurrently, such as multiple clients accessing a server at the same time.



# ASP.NET Core

## Introduction to .NET Core (Which now is only called .NET)
- .NET was not a new version of the .NET Framework, but it was an entirely new framework created to build Desktop, Web, Cloud and Mobile Applications.
- With .NET 5 it is unified 
- It is a Cross-Platform and Open-Source Framework developed by Microsoft and released under MIT License
- .NET is a modular framework, and so it is possible to run two web applications with different versions of .NET on the same Server

- What can you make with it?
  - Desktop Apps
  - WEb apps
  - Cloud Apps
  - mobile Apps
  - Games
  - IoT
  - AI

- Some components of .NET
  - Entity Framework Core - It is an open-source and cross-platform version of the Entity Framework. It Serves as Object Relation model (ORM) to connect to the database using the entity model.
  - Identity Core - Identity Core is used to implement the form of authentication and roles and permission. It allows us to implement the login and register features to the application
  - MVC Core - MVC Core is an open-source MVC project under the .NET Core framework
  - Razor Core (Razor Pages) - Razor Pages is a project type under the .NET Core framework. It's a new type of project where there is no need to write controllers, and the controller logic and the routing can be placed in the view page itself.
  - SignalR - is a free and open-source software library for ASP.NET
  - Blazor - Blazor .NET is an experimental project from Microsoft that allows developers to write the client-side code in C# language. It is composed of reusable components and servers the requirement of a single page application. It is based on the We Assembly concept.


# Made by 
- [Luke Dias](https://github.com/HollowLukeDias)